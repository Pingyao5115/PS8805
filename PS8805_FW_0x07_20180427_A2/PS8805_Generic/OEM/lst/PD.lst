C51 COMPILER V8.02   PD                                                                    04/27/2018 15:47:22 PAGE 1   


C51 COMPILER V8.02, COMPILATION OF MODULE PD
OBJECT MODULE PLACED IN .\OEM\Obj\PD.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE CL_Functions\sources\PD.c OMF2 BROWSE VARBANKING DEBUG PRINT(.\OEM\lst\PD.l
                    -st) OBJECT(.\OEM\Obj\PD.obj)

line level    source

   1          /**
   2            ******************************************************************************
   3            * @file  PD.c 
   4            * @author Jingbo.Li 
   5            * @version V1.0.0
   6            * @date    10/30/2015
   7            * @brief   
   8            ******************************************************************************
   9            */ 
  10          
  11          #include <myDP8051XP.H>
  12          #include "registers_map.h"
  13          #include "PD.h"
  14          #include "global.h"
  15          
  16          void Physical_Layer_Init(void)
  17          {
  18   1      //      unsigned short xdata usxDelay = 150;
  19   1      //      unsigned char idata uciData;
  20   1      
  21   1              AOI_REG_ANATOP_15_8 |= 0x10;//Disable I2C LAST
  22   1      //      AOI_REG_ANATOP_63_56 = 0x25;//<7:5> I2C_ACTIVE_LAST:001:75mS
  23   1      
  24   1      //      AOI_REG_PDC_39_32 = 0x40;//<6> Enable CC R/I select
  25   1      
  26   1      //      ADDRCFG0 = 0x17;//disable I2C access
  27   1      //      ADDRCFG4 = 0x8B;//[7]TESTI2CEN,[6:0]slave address[7:1]
  28   1      //      MPU_HOLD_MODE = 0x07;//[2]MPU_HOLD_MODE  enable, [1]WR_HOLD, [0]RD_HLD
  29   1              REG_IRQ_SRC_CTL = 0x81;//[0]enable ALERT to TCPM[6]disable ALERT to MPU
  30   1      //      REG_IRQ_SRC_CTL = 0xC1;//[0]enable ALERT to TCPM[6]enable ALERT to MPU
  31   1              FUNC_IRQ_MASK = 0xBF;//page3 write remapping
  32   1              FAULT_STATUS_MASK = 0x00;//0b: Interrupt masked
  33   1      
  34   1      //      CTL_DEBUG_SEL = 0x20;//get I2C slave address
  35   1      //      DEBUG_IN;//01:0x10;13:0x30;25:0x50;39:0x90
  36   1      
  37   1              REG_STRETCH |= 0x60;//read page 3 from control I2c to wakeup
  38   1              REG_DLPF_CTRL0 |= 0x60;//sample 64 times for average
  39   1              REG_DET_CTRL1 = 0x64;
  40   1              REG_DET_CTRL2 = 0x10;//[4:3]VBUS_CAL_SEL:100mv
  41   1              REG_DET_CTRL3 = 0x50;//REG_VSAFE0V = 0.8V,[6]VCONNEN_CLR_MASK
  42   1      /*
  43   1      #ifdef TCPM_DEBOUNCE
  44   1              REG_CC_DET_INT_MASK0 = 0xC7;//CC1_CONN_FILT_INT_MASK,CC2_CONN_FILT_INT_MASK,VBUS_CONN_FILT_INT_MASK
  45   1              REG_CC_DET_INT_MASK1 = 0xC7;//CC1_DISCONN_FILT_INT_MASK,CC2_DISCONN_FILT_INT_MASK,VBUS_DISCONN_FILT_INT_M
             -ASK
  46   1      #else
  47   1              REG_DEBOUNCE_CTRL0 = 0x00;//CC attach debounce 10ms
  48   1              REG_DEBOUNCE_CTRL1 = 0x02;//CC detach debounce 3ms
  49   1      //      REG_DEBOUNCE_CTRL1 |= 0x40;//FILT_SEL enable    
  50   1              REG_CC_DET_INT_MASK0 = 0xF8;//CC1_CONN_DEB_INT_MASK,CC2_CONN_DEB_INT_MASK,VBUS_CONN_DEB_INT_MASK
  51   1              REG_CC_DET_INT_MASK1 = 0xF8;//CC1_DISCONN_DEB_INT_MASK,CC2_DISCONN_DEB_INT_MASK,VBUS_DISCONN_DEB_INT_MASK
  52   1      #endif
  53   1      */
C51 COMPILER V8.02   PD                                                                    04/27/2018 15:47:22 PAGE 2   

  54   1              REG_DEBOUNCE_CTRL0 = 0x00;//CC attach debounce 10ms
  55   1              REG_DEBOUNCE_CTRL1 = 0x02;//CC detach debounce 3ms
  56   1              REG_DEBOUNCE_CTRL3 = 0x00;//vbus attach debounce 10ms
  57   1              REG_DEBOUNCE_CTRL4 = 0x82;//vbus detach debounce 3ms
  58   1      
  59   1      //      CC_DET_IRQ_STATUS2 = 0xFF;
  60   1      //      CC_DET_IRQ_STATUS4 = 0xFF;
  61   1              REG_CC_DET_INT_MASK2 = 0x87;
  62   1              REG_CC_DET_INT_MASK4 = 0xBE;//[6]PC_VCONN_EN_CHG_INT_MASK,[0]PC_FCDICHAR_CHG_INT_MASK
  63   1              AOI_REG_PDC_95_88 &= 0x3F;
  64   1              REGHPD |= 0x02;//[1] TCPC_EN for analog
  65   1              REG_HPD_TOG = 0x02;//Toggle time 1.2ms
  66   1      
  67   1              REG_GPIO_OEB = 0;//GPIO output
  68   1              REG_GPIOP_OEB = 0;//GPIO output
  69   1      //      ENABLE_DISCHARGE_VBUS;
  70   1              REG_GPIO_SEL = REG_GPIO_SEL | GPIO5;
  71   1              REG_GPIO_OUT = REG_GPIO_OUT & (~GPIO5);
  72   1      //      REG_GPIOP_SEL = REG_GPIOP_SEL | GPIO0 | GPIO1 | GPIO2 | GPIO3 | GPIO4 | GPIO5 | GPIO6 | GPIO7;
  73   1      //      REG_GPIOP_OUT = REG_GPIOP_OUT & (~GPIO0) & (~GPIO1) & (~GPIO2) & (~GPIO3) & (~GPIO4) & (~GPIO5) & (~GPI
             -O6) & (~GPIO7);
  74   1      
  75   1      //      REG_WID_SEL |= 0x08;//I2C R/W IRQ EN
  76   1      
  77   1      //      C2SS_WU1_REG = 0xE0;//Port1 signal detector threshold adjust    
  78   1      
  79   1              REG_OPTION_CTR = 0x58;// Bit[4]:  1: The Rx message alert is asserted after GoodCRC is sent.
  80   1                                                              //0: The Rx message alert is asserted before GoodCRC is sent.
  81   1      
  82   1              AOP_REG_PDC_63_56 = 0x02;//<1:0>receiver's hysteresis control:10:300mV
  83   1              GOODCRC_BUS_IDLE_TIMER_BYTE_0 = 0xE6;//200.2us good
  84   1              GOODCRC_BUS_IDLE_TIMER_BYTE_1 = 0x0A;   // GCRC bus idle timer, it is setting into 195 us now (15MHz)
  85   1      
  86   1      /*      BMC_PHY_CTR0 = 0x31;
  87   1              BMC_PHY_CTR1 = 0x53;
  88   1              BMC_PHY_CTR2 = 0x03;
  89   1              BMC_PHY_CTR3 = 0x06;
  90   1              BMC_PHY_CTR4 = 0x84;
  91   1              BMC_PHY_CTR5 = 0x00;
  92   1              BMC_PHY_CTR6 = 0x00;
  93   1              BMC_PHY_CTR7 = 0x00;
  94   1              BMC_PHY_CTR8 = 15 * 5;
  95   1              BMC_PHY_CTR9 = 0x96;
  96   1      
  97   1              REG_WID_SEL = 0x07;
  98   1      
  99   1              REG_OPTION_CTR_1 = 0x07;//HW control GOODCRC header info
 100   1      
 101   1              GOODCRC_BUS_IDLE_TIMER_BYTE_0 = 0x8B;
 102   1              GOODCRC_BUS_IDLE_TIMER_BYTE_1 = 0x0B;   // GCRC bus idle timer, it is setting into 195 us now (15MHz)
 103   1              GDCRC_TIMER_BYTE0 = 0x7C;
 104   1              GDCRC_TIMER_BYTE1 = 0x01; // RX GCRC sending timer, it is setting into 25 us now
 105   1              GOODCRC_RECEIVE_TIMER_BYTE0 = 0x98;
 106   1              GOODCRC_RECEIVE_TIMER_BYTE1 = 0x3A;
 107   1      
 108   1              VENDOR_ID_L = USB_Vendor_ID & 0xFF;
 109   1              VENDOR_ID_H = USB_Vendor_ID >> 8;
 110   1              PRODUCT_ID_L = USB_Product_ID & 0xFF;
 111   1              PRODUCT_ID_H = USB_Product_ID >> 8;
 112   1              DEVICE_ID_L = BCDDEVICE & 0xFF;
 113   1              DEVICE_ID_H = BCDDEVICE >> 8;
 114   1              USBTYPEC_REV_L = 0x10;
C51 COMPILER V8.02   PD                                                                    04/27/2018 15:47:22 PAGE 3   

 115   1              USBTYPEC_REV_H = 0;
 116   1              USBPD_REV_VER_L = 0x12;
 117   1              USBPD_REV_VER_H = 0x20;
 118   1              PD_INTERFACE_REV_L = 0x11;
 119   1              PD_INTERFACE_REV_H = 0x10;*/
 120   1      
 121   1              BMC_PHY_CTR4 = 0xC4;
 122   1              BMC_PHY_CTR11 = 0x04;
 123   1              MESSAGE_HEADER_INFO = 0x02;
 124   1      
 125   1              PRODUCT_ID_L = USB_Product_ID & 0xFF;
 126   1              DEVICE_CAPABILITIES_1 = ROLES_SUPPORTED | SOPP_DBG_OR_SOPDP_DBG_SUPPORT | SOURCE_VCONN/* | SINK_VBUS | SO
             -URCE_HIGH_VOLTAGE_VBUS | SOURCE_VBUS*/;//0xB8;
 127   1              DEVICE_CAPABILITIES_2 = /* BLEED_DISCHARGE |*/ FORCE_DISCHARGE | VBUS_MEASUREMENT_AND_ALARM_CAPABLE | SOU
             -RCE_RESISTOR_SUPPORTED;//0x0E;
 128   1      #ifdef VBUS_OCP
 129   1      //      DEVICE_CAPABILITIES_2 |= VBUS_OCP_REPORTING;
 130   1      //      REG_DEBOUNCE_CTRL3 |= VBUS_OCP_GPIO;//[7:5]SW_ANA_OCP_SEL
 131   1      #else
              //      DEVICE_CAPABILITIES_2 |= VBUS_OVP_REPORTING;
              #endif
 134   1              DEVICE_CAPABILITIES_3 = /*SINK_DISCONNECT_DETECTION |*/ STOP_DISCHARGE_THRESHOLD | VBUS_VOLTAGE_ALARM_LSB
             - | VCONN_POWER_SUPPORTED/* | VCONN_OVERCURRENT_FAULT_CAPABLE*/;//0x62
 135   1              DEVICE_CAPABILITIES_4 = 0x00; 
 136   1              STANDARD_INPUT_CAPABILITIES = 0;//VBUS_EXTERNAL_OVER_CURRENT_FAULT;// | FORCE_OFF_VBUS;//0x03;
 137   1              STANDARD_OUTPUT_CAPABILITIES = MUX_CONFIGURATION_CONTROL | CONNECTION_PRESENT | CONNECTOR_ORIENTATION | V
             -BUS_PRESENT_MONITOR;//0x27;
 138   1      
 139   1              VBUS_SINK_DISCONNECT_THRESHOLD_L = 200;
 140   1              VBUS_SINK_DISCONNECT_THRESHOLD_H = 0x00;
 141   1              VBUS_STOP_DISCHARGE_THRESHOLD_L = 0x20;
 142   1              VBUS_STOP_DISCHARGE_THRESHOLD_H = 0x00;
 143   1              VBUS_VOLTAGE_ALARM_HI_CFG_L = 240;
 144   1              VBUS_VOLTAGE_ALARM_HI_CFG_H = 0x00;
 145   1              VBUS_VOLTAGE_ALARM_LO_CFG_L = 0x00;
 146   1              VBUS_VOLTAGE_ALARM_LO_CFG_H = 0x00;
 147   1      
 148   1              AOP_REG_PDC_63_56 = 0x01;//receiver's hysteresis control
 149   1              AOP_REG_PDC_79_72 = 0x03;//SST Driver output peak value tuning -8.34%
 150   1              AOI_REG_PDC_15_8 = 0xC0;//wake up 160us
 151   1      //      AOI_REG_PDC_23_16 |= 0x01;//<0>Select Rp initial toggle when CC1 & CC2 is open, 0: Rd, 1: Rp
 152   1              AOI_REG_PDC_31_24 |= 0x10;//<4> select DRP toggle condition
 153   1                                                                //0: both of CC are RD or Rp
 154   1                                                                //1: both of CC are open
 155   1      //      AOI_REG_PDC_23_16 |= 0x02;//<1> select debounce signal
 156   1                                                               //0: Ra only will keep wake up
 157   1                                                               //1: Ra only will sleep
 158   1              REGDD &= 0xBF;//[6]0:don't change status when masked
 159   1              REGDD |= 0x20;//GoodCrc header byte is set to specification revision
 160   1      #if 0//debug
                      REG_VENDOR_CTRL2 |= 0x10;//not clear RECEIVE_BYTE_COUNT when alert is cleared
                      REG_VENDOR_CTRL2 |= 0x04;//not clear RECEIVE_BYTE_COUNT when received hardreset
                      REG_VENDOR_CTRL3 |= 0x02;//not clear RECEIVE_BYTE_COUNT when send hardreset
              #endif
 165   1              REG_VENDOR_CTRL4 |= 0x80;//[7]FRS_DET_DIG_MASK
 166   1                                                               //Mask function of stopping transmitting CC message when detecting fast_role_swap signal
 167   1                                                               //1:enable,0:disable
 168   1              REG_POWER_STATUS |= 0x08;//POWER_STATUS: [3]VBUS Present Detection Enabled
 169   1              POWER_CONTROL &= 0xBF;//[6]VBUS_VOLTAGE Monitoring is enabled
 170   1      
 171   1      //      OTHER_CTRL3 &= 0xDF;//[5]CC_CONN_ENWIN_MASK
 172   1      
C51 COMPILER V8.02   PD                                                                    04/27/2018 15:47:22 PAGE 4   

 173   1              ADDRCFG0 = 0x10;//enable I2C access
 174   1      //      ADDRCFG0 = 0x17;//enable I2C access
 175   1      //REG_GPIOP_OUT = REG_GPIOP_OUT | GPIO6;
 176   1      
 177   1      /*      REG_RUSB_DRV_7_0 = 0x03;//set swing to decrease by 3 levels
 178   1              REG_RUSB_DRV_15_8 = 0x04;//set preshoot on for rx as lvl 4
 179   1              REG_RUSB_DRV_23_16 = 0x16;//set de-emphasis on for rx as lvl 6
 180   1              //SIGNALDET rising and falling edge timing
 181   1              REG_EQTX_31_24 = 0x09;//TUSB SD falling edge timing and rising edge timing, 20180131
 182   1              REG_EQRX_23_16 = 0x40;//RUSB SD rising edge timing, 20180131
 183   1              REG_EQRX_31_24 = 0x02;//RUSB SD falling edge timing, 20180131
 184   1              //TX De-emphasis and Preshoot settings
 185   1              REG_TUSB_DRV_15_8 = 0x8b;//set de-emphasis (lvl 3) on and preshoot(lvl 1)  on for tx,20180118
 186   1      */
 187   1              if ( ( POWER_ON_RESET & 0x01 ) == 0 )//POWER_ON_RESET: 0:power on reset;1:wake up
 188   1              {
 189   2      /*              //CEQ
 190   2                      AOI_REG_ANATOP_47_40 = 0x1E;
 191   2                      AOI_REG_ANATOP_39_32 = 0x07;//db
 192   2                      //SSEQ
 193   2                      AOI_REG_ANATOP_31_24 = 0x1E;
 194   2      */
 195   2                      POWER_ON_RESET |= 0x01;
 196   2      g_vucxReg0[0x5C]++;
 197   2                      ALERT_MASK_LOW  = 0xFE; //0b: Interrupt masked,1b: Interrupt unmasked
 198   2                      ALERT_MASK_HIGH = 0x01; 
 199   2                      POWER_STATUS_MASK = 0x04;//[2]VBUS Present Status Interrupt UnMask      
 200   2              
 201   2      #ifdef ENABLE_AUTO_POWER_DOWN
 202   2      /*              AOI_REG_ANATOP_15_8 |= 0x80;//FIRMCMD_AUTOPD_EN
 203   2                      usxDelay = 30;
 204   2                      while ( usxDelay-- );
 205   2                      AOP_REG_ANATOP_7_0 |= 0x10; //sleep,auto clear when wakeup*/
 206   2                      AOI_REG_ANATOP_15_8 &= 0x7F;//disable FIRMCMD_AUTOPD_EN
 207   2      #endif
 208   2      
 209   2      #ifdef HW_MODE
                              REG_DET_CTRL0 = 0x04;//HW MODE
              #else
 212   2                      REG_DET_CTRL0 = 0x84;//SW MODE
 213   2      #endif
 214   2                      g_vucxReg2[0x30] = REG_DET_CTRL0;
 215   2              }
 216   1              else
 217   1              {
 218   2                      REGDD |= 0x10;//set POWER_STATUS change alert
 219   2                      if ( STA_P2_75 & 0x30 )//WK_I2C_STAT or WK_PLUG_STAT
 220   2                      {
 221   3                              //clear WK_I2C_STAT & WK_PLUG_STAT
 222   3                              REG_MI2C_MODE |= 0x10;
 223   3                              REG_MI2C_MODE &= 0xEF;
 224   3                      }
 225   2              }
 226   1      
 227   1              REG_DET_CTRL0 = g_vucxReg2[0x30];
 228   1      
 229   1              ALERT_STATUS_1 = 0xFF;
 230   1              ALERT_STATUS_2 = 0xFF;
 231   1      #ifdef TCPM_DEBOUNCE
 232   1      //      CC_DET_IRQ_STATUS0 = 0xFF;
 233   1              REG_CC_DET_INT_MASK0 = 0xC7;//CC1_CONN_FILT_INT_MASK,CC2_CONN_FILT_INT_MASK,VBUS_CONN_FILT_INT_MASK
 234   1      #else
C51 COMPILER V8.02   PD                                                                    04/27/2018 15:47:22 PAGE 5   

              //      CC_DET_IRQ_STATUS0 = 0xFF;
                      REG_CC_DET_INT_MASK0 = 0xF8;//CC1_CONN_DEB_INT_MASK,CC2_CONN_DEB_INT_MASK,VBUS_CONN_DEB_INT_MASK
              #endif
 238   1      //      CC_DET_IRQ_STATUS1 = 0xFF;
 239   1              REG_CC_DET_INT_MASK1 = 0xF8;//CC1_DISCONN_DEB_INT_MASK,CC2_DISCONN_DEB_INT_MASK,VBUS_DISCONN_DEB_INT_MASK
 240   1      //      ALERT_STATUS_2 = 0x02;//[1]ALERT_REGISTER.Fault
 241   1      
 242   1      #if 0
                      g_vucxReg6[0x3E] = 0x44;
                      g_vucxReg2[0x4F] = 0x03;
                      g_vucxReg2[0x25] = 0x00;
                      g_vucxReg2[0x2A] |= 0x20;
              #endif
 248   1      
 249   1      /*      //transmit message successful signal on GPIOP2
 250   1              g_vucxReg3[0xc0] = 0x5;
 251   1              g_vucxReg2[0x4f] = 0x1;
 252   1              g_vucxReg2[0x25] = 0x0;
 253   1              g_vucxReg2[0x2a] = 0x20;*/
 254   1      }
 255          
 256          void VBUS_Force_Discharge(void)
 257          {
 258   1              REG_DET_CTRL2 &= 0x9B;//stop
 259   1              REG_DET_CTRL2 |= 0x20;//SW_ADC_VBUS_EN
 260   1              REG_DET_CTRL2 |= 0x40;//SW_DLPF_START
 261   1      //REG_GPIOP_OUT = REG_GPIOP_OUT | (GPIO7);
 262   1              while ( (!(CC_DET_IRQ_STATUS2 & 0x04)) /*&& ( REG_DET_CTRL2 & 0x40 )*/ )
 263   1              {
 264   2                      if ( g_ucxExitSample )
 265   2                      {
 266   3                              g_ucxExitSample = 0;
 267   3      //                      g_ucxVBUS_Force_Discharge = 0;//?
 268   3                              return;
 269   3                      }
 270   2                      g_vucxReg5[0x81]++;
 271   2              }
 272   1              CC_DET_IRQ_STATUS2 = 0x04;
 273   1              REG_DET_CTRL2 &= 0x9B;//stop
 274   1              REG_DET_CTRL2 |= 0x04;//[2]SW_ADC_DET_DONE_VBUS
 275   1              REG_DET_CTRL2 &= 0xFB;
 276   1      //REG_GPIOP_OUT = REG_GPIOP_OUT & (~GPIO7);
 277   1      //      VBUS_VOLTAGE = ( (unsigned short)REG_VBUS_DCC << 2 ) | 0x0800;//REG_VBUS_DCC:100mV per bit;VBUS_VOLTAGE
             -:25mV per bit
 278   1              g_usx_VBUS_STOP_DISCHARGE = (unsigned short)REG_VBUS_DCC << 2;//convert to 25mV per bit
 279   1              if ( g_usx_VBUS_STOP_DISCHARGE < VBUS_STOP_DISCHARGE_THRESHOLD_L + VBUS_STOP_DISCHARGE_THRESHOLD_H * 256 
             -)//stop discharge
 280   1              {
 281   2                      DISABLE_DISCHARGE_VBUS;
 282   2      //              g_ucxVBUS_Discharge = 0;//?
 283   2                      g_ucxVBUS_Force_Discharge = 0;//?
 284   2                      POWER_CONTROL &= 0xFB;
 285   2      //              g_vucxReg5[0x10]= g_usx_VBUS_STOP_DISCHARGE & 0xFF;
 286   2      //              g_vucxReg5[0x11]= g_usx_VBUS_STOP_DISCHARGE >> 8;
 287   2      //              g_vucxReg5[0x12]= REG_VBUS_DCC;
 288   2              }
 289   1      }
 290          /*
 291          void Sink_Auto_Discharge(void)
 292          {
 293                  REG_DET_CTRL0 &= 0xB4;//stop
 294                  REG_DET_CTRL2 &= 0x9B;//stop
C51 COMPILER V8.02   PD                                                                    04/27/2018 15:47:22 PAGE 6   

 295                  REG_DET_CTRL2 |= 0x20;//SW_ADC_VBUS_EN
 296                  REG_DET_CTRL2 |= 0x40;//SW_DLPF_START
 297                  while ( !(CC_DET_IRQ_STATUS2 & 0x04) );
 298                  CC_DET_IRQ_STATUS2 = 0x04;
 299                  REG_DET_CTRL2 &= 0x9B;//stop
 300          //      REG_DET_CTRL2 |= 0x04;//[2]SW_ADC_DET_DONE_VBUS
 301          //      REG_DET_CTRL2 &= 0xFB;
 302          //      VBUS_VOLTAGE = ( REG_VBUS_DCC << 2 ) | 0x0800;//REG_VBUS_DCC:100mV per bit;VBUS_VOLTAGE:25mV per bit
 303                  g_usx_VBUS_SINK_DISCONNECT = ( (unsigned short)REG_VBUS_DCC ) << 2;//convert to 25mV per bit
 304                  if ( g_usx_VBUS_SINK_DISCONNECT < VBUS_SINK_DISCONNECT_THRESHOLD_L + VBUS_SINK_DISCONNECT_THRESHOLD_H * 2
             -56 )//start to discharge
 305                  {
 306                          ENABLE_DISCHARGE_VBUS;
 307                  }
 308          }*/
 309          
 310          void Delay( unsigned char ucMilliSec )
 311          {
 312   1              unsigned char idata i;
 313   1      
 314   1              for ( i = 0; i < ucMilliSec; i++ )
 315   1              {
 316   2                      usxDelay = 375;
 317   2                      while ( usxDelay-- );
 318   2              }
 319   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    598    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----       1
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
